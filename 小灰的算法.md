# (一)、数据结构

## 一、数组

####  基本操作

1. 读取元素 O(1)

   根据数组下标读取元素 --随机读取

2. 更新元素  时间复杂度  O(1)

3. 插入元素

   + 尾部插入

   + 中间插入 O(n)

     从数组的中间插入数据，后面的数需要依次后移

     ```java
     //lenth 数组实际内容长度
     public void insertArray(int []array, int lenth,int insertIndex,int element){
         if(lenth > insertIndex || insertIndex < 0){
             throw new IndexOutOfBoundsException("超出数组实际元素范围")
         }
         for(int i = lenth;i>insertIndex;i--){
             array[i] = array[i-1]
         }
         array[insertIndex]=element;
         lenth++;
     }
     ```

   + 超范围插入 O(n)+O(n)=O(n)

     数组已满，插入数据的时候，可以把数组转移到另外一个2倍大的数组里，再进行中间插入

4. 删除元素 O(n)

   如果删除的元素位于数组中间，则需要把后面的元素向前挪动一位

   ```java
   /* array 数组  size 数组实际最后一个元素所在的下标 index 删除的元素所在的下标 */
   public int delete(int index){
       if(index<0||index > size){
           return error;
       }
       int deleteElement = array[index];
       for(int i = index;i<size-1;i++){
           array[i]=array[i+1];
       }
       size--;
       return deleteElement;
   }
   ```

   另一种操作方法：将数组的最后一个元素复制到将要删除的元素所在的位置，然后删除最后一个元素，当然这不是删除元素的主流操作方式。

#### 优缺点

+ 非常高效的随机访问能力（二分查找）
+ 插入删除操作不便
+ 数组适合读操作多，写操作少的场景



## 二、链表

+ 单向链表

  ```java
  private static class Node{
      int data;
      Node next;
  }
  ```

+ 双向链表

  ```java
  private static class Node{
      int data;
      Node prev;
      Node next;
  }
  ```

+ 链表是随机存储的

#### 基本操作

- 查找节点

  从头节点开始遍历，直到查找到目标节点，最坏的时间复杂度是O(n)

- 更新节点

  查找到节点后，对数据进行更新

- 插入节点

  + 尾部插入

    把最后一个节点的next指针指向新的节点

  + 头部插入

    把新节点的next指针指向头节点，把新节点变为链表的头节点

  + 中间插入

    新节点的next指针指向插入位置的节点

    插入位置的前置节点的next指针指向新的节点

- 删除元素

  - 尾部删除

    把倒数第二节点的next指针指向空

  - 头部删除

    把头节点的next指针指向的节点设置为头节点

  - 中间删除

    把删除位置的前置节点的next指针指向删除位置的下一个节点

java有垃圾回收机制，对于没有外部引用指向的节点，会被自动回收。

如果不考虑插入、删除之前查找元素的过程，只考虑纯粹的插入和删除操作，时间复杂度都是O(1)

```java
public class NodeList {
    private static class Node{
        int data;
        Node next;
        Node(int data){
            this.data = data;
        }
    }
    //头节点
    private Node head;
    //尾部节点
    private Node last;
    //链表实际长度
    private int size;

    //根据data的值寻找节点
    public Node find(int data){
        Node findNode = head;
        while (findNode!=null){
            if(findNode.data == data){
                return findNode;
            }else{
                findNode = findNode.next;
            }
        }
        return null;
    }

    //根据index查找第几个节点
    public Node findIndex(int index) throws Exception{
        if(index<0||index>=size){
            throw new IndexOutOfBoundsException("超出链表节点范围");
        }
        Node temp = head;
        for(int i=0;i<index;i++){
            temp = temp.next;
        }
        return temp;
    }

    //插入节点
    public boolean insert(int data,int index)throws Exception{
        if(index<0||index>size){
            throw new IndexOutOfBoundsException("超出链表节点范围");
        }
        Node nodeInsert = new Node(data);
        if(size==0){
            //链表为空
            this.head = nodeInsert;
            this.last = nodeInsert;
        }else if(index==0){
            //插入的位置为头结点
            nodeInsert.next = this.head;
            this.head = nodeInsert;
        }else if(index==size){
            //插入的位置为尾节点
            this.last.next = nodeInsert;
            this.last = nodeInsert;
        }else{
            //插入的位置为中间位置
            Node preNode = findIndex(index-1);
            nodeInsert.next = preNode.next;
            preNode.next=nodeInsert;
        }
        size++;
        return true;
    }

    //删除节点
    public Node delete(int index)throws Exception{
        if(index<0||index>=size){
            throw new IndexOutOfBoundsException("超出链表节点范围");
        }
        Node removeNode = null;
        if(index==0){
            //删除头结点
            removeNode = this.head;
            this.head = this.head.next;
        }else if(index == size-1){
            //删除尾节点
            Node prevNode = findIndex(size-1);
            removeNode = this.last;
            prevNode.next = null;
            this.last = prevNode;
        }else{
            //删除中间节点
            Node prevNode = findIndex(index-1);
            removeNode = prevNode.next;
            prevNode.next = prevNode.next.next;
        }
        size--;
        return removeNode;
    }
}
```

#### 优缺点

数组与链表的对比

|      | 查找 | 更新 | 插入 | 删除 |
| ---- | ---- | ---- | ---- | ---- |
| 数组 | O(1) | O(1) | O(n) | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(1) |

+ 更加灵活地进行插入和删除操作
+ 适合在尾部频繁插入、删除元素

## 三、栈

+ **先入后出** 

  最早进入的元素存放的位置是**栈底**

  最后进入的元素存放的位置是**栈顶**

+ 基本操作  O(1)

  + 入栈
  + 出栈

## 四、队列

+ **先入先出 FIFO**

  出口端叫做**队头**

  入口端叫做**队尾**

  用数组实现时，为了入队操作的方便，把队尾的位置规定为最后入队元素的下一个位置。

+ 基本操作  O(1)

  + 入队
  + 出队

  用数组实现的队列可以使用循环队列的方式来维持队列容量的恒定。

  (队尾下标+1)%数组长度=队头下标时，代表队列已满，队尾指针指向的位置永远空出一位

  所以队列最大容量=数组长度-1

```java
public class MyQueue {
    private int []array;
    private int front;
    private int rear;
    public MyQueue(int size){
        this.array = new int[size];
    }
    //入队
    public void inQueue(int value)throws Exception{
        if((rear+1)%array.length == front){
            throw new Exception("队列已满");
        }
        array[rear]=value;
        rear = (rear+1)%array.length;
    }
    //出队
    public int outQueue()throws Exception{
        if(rear == front){
            throw new Exception("队列已空");
        }
        int outValue = array[front];
        front=(front+1)%array.length;
        return outValue;
    }
    //输出队列
    public void outPutQueue(){
        for (int i=front;i!=rear;i=(i+1)%array.length){
            System.out.println(array[i]);
        }
    }
}
```

#### 栈和队列的应用

+ 实现递归的逻辑，可以使用栈来代替，因为栈可以回溯方法，还有一个著名的应用场景是 **面包屑导航** ，使用户在浏览页面时可以轻松地回溯到上一级或者更上一级页面。
+ 队列应用到多线程中，争夺公平锁的等待队列。网络爬虫把待爬取的网站url存入队列中。
+ **双端队列 deque**  队头队尾均可入队或出队
+ **优先队列** 基于二叉堆来实现，谁的优先级高谁优先出队

## 五、散列表/哈希表 hash table

#### 写操作

在散列表中插入键值对

- 通过哈希函数，把key转换成数组下标
- 保存到数组里

**哈希冲突**

+ 开放寻址法

  寻址当前元素的下一个位置是否为空，为空则可以占用

+ 链表法

  哈希数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点，当有冲突试，插入到对应的链表中即可。

#### 读操作

- 通过哈希函数，把key转换成数组下标x
- 在数组中的下标x处找对应的元素

#### 扩容

散列表会在多次插入后达到一定饱和度，key映射位置发生冲突的概率会提高

**步骤**

- 扩容，创建一个新的entry空数组，长度是原来的2倍
- 重新hash，扩容后hash规则会随之改变，把所有的entry重新hash到新的数组中。

## 六、二叉树

+ 满二叉树
+ 完全二叉树

#### 二叉树的数组存储

父节点的下标是`parent`，则其左孩子节点的下标是`2*parent+1 `,右孩子节点下标是`2*parent+2`

对于稀疏的二叉树来说，用数组表示法是非常浪费空间的。

#### 二叉树的应用

##### 二叉查找树

- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左右子树也都是二叉查找树

##### 二叉排序树

​	二叉排序树也就是二叉查找树，新插入节点时根据上述规则来插入数据，但是会造成二叉树不平衡。解决不平衡的方式：红黑树，AVL树，树堆。

#### 二叉树的遍历

##### 1.深度优先遍历

- 前序遍历

  根节点->左子树->右子树

- 中序遍历

  左子树->根节点->右子树

- 后序遍历

  左子树->右子树->根节点

```java
public class LinkTree {
    private static class TreeNode{
        int data;
        TreeNode leftChild;
        TreeNode rightChild;
        TreeNode(int data){
            this.data = data;
        }
    }
    //构建二叉树
    public static TreeNode createBinaryTree(LinkedList<Integer> inputList){
        TreeNode node = null;
        if(inputList==null||inputList.isEmpty()){
            return null;
        }
        Integer data = inputList.removeFirst();
        if(data != null){
            node = new TreeNode(data);
            node.leftChild = createBinaryTree(inputList);
            node.rightChild = createBinaryTree(inputList);
        }
        return node;
    }

    //递归深度优先遍历
    //前序遍历
    public static void preOrderTraveral(TreeNode node){
        if(node==null) return;
        System.out.println(node.data);
        preOrderTraveral(node.leftChild);
        preOrderTraveral(node.rightChild);
    }
    //中序遍历
    public static void inOrderTraveral(TreeNode node){
        if(node==null) return;
        inOrderTraveral(node.leftChild);
        System.out.println(node.data);
        inOrderTraveral(node.rightChild);
    }
    //后序遍历
    public static void postOrderTraveral(TreeNode node){
        if(node==null) return;
        postOrderTraveral(node.leftChild);
        postOrderTraveral(node.rightChild);
        System.out.println(node.data);
    }
    //非递归深度优先遍历
    //二叉树非递归前序遍历 V1
    public void preOrderTravelStackV1(TreeNode root){
        if(root==null) return;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode treeNode = root;
        while(treeNode!=null || !stack.isEmpty()){
            while (treeNode!=null){
                System.out.println(treeNode.data);
                stack.push(treeNode);
                treeNode=treeNode.leftChild;
            }
            if(!stack.isEmpty()){
                treeNode = stack.pop();
                treeNode = treeNode.rightChild;
            }
        }
    }
    //二叉树非递归前序遍历 V2
    public void preOrderTravelStackV2(TreeNode root){
        if(root==null) return;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode treeNode = root;
        while(treeNode!=null || !stack.isEmpty()){
            if(treeNode!=null){
                System.out.println(treeNode.data);
                stack.push(treeNode);
                treeNode = treeNode.leftChild;
            }else{
                treeNode = stack.pop();
                treeNode = treeNode.rightChild;
            }
        }
    }
    //二叉树非递归前序遍历 V3
    public void preOrderTravelStackV3(TreeNode root){
        if(root==null) return;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode treeNode = root;
        stack.push(treeNode);
        while(!stack.isEmpty()){
            System.out.println(treeNode.data);
            if(treeNode.rightChild!=null){
                stack.push(treeNode.rightChild);
            }
            if(treeNode.leftChild!=null){
                treeNode = treeNode.leftChild;
            }else{
                treeNode = stack.pop();
            }
        }
    }
    //二叉树非递归中序遍历 v1
    public void inOrderTravelStackV1(TreeNode root){
        if(root==null) return;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode treeNode = root;
        while(treeNode!=null || !stack.isEmpty()){
            while (treeNode!=null){
                stack.push(treeNode);
                treeNode=treeNode.leftChild;
            }
            if(!stack.isEmpty()){
                treeNode = stack.pop();
                System.out.println(treeNode.data);
                treeNode=treeNode.rightChild;
            }
        }
    }
    //二叉树非递归中序遍历 v2
    public void inOrderTravelStackV2(TreeNode root){
        if(root==null) return;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode treeNode = root;
        while (treeNode!=null || !stack.isEmpty()){
            if(treeNode==null){
                treeNode = stack.pop();
                System.out.println(treeNode.data);
                treeNode = treeNode.rightChild;
            }else{
                stack.push(treeNode);
                treeNode = treeNode.leftChild;
            }
        }
    }
    //二叉树非递归后序遍历 v1
    public void postOrderTravelStackV1(TreeNode root){
        Stack<TreeNode> stack1 = new Stack<TreeNode>();
        Stack<TreeNode> stack2 = new Stack<TreeNode>();
        TreeNode treeNode = root;
        stack1.push(treeNode);
        while(!stack1.isEmpty()){
            TreeNode cur = stack1.pop();
            stack2.push(cur);
            if(cur.leftChild!=null) stack1.push(cur.leftChild);
            if(cur.rightChild!=null) stack1.push(cur.rightChild);
        }
        while (!stack2.isEmpty()){
            System.out.println(stack2.pop().data);
        }
    }
    //二叉树非递归后序遍历 v2
    public void postOrderTravelStackV2(TreeNode root){
        if(root==null) return;;
        Stack<TreeNode> stack= new Stack<TreeNode>();
        TreeNode lastVisit=null;
        TreeNode treeNode = root;
        while (treeNode!=null){
            stack.push(treeNode);
            treeNode = treeNode.leftChild;
        }
        while (!stack.isEmpty()){
            treeNode = stack.pop();
            //走到这里，treeNode 都是空的，并且已经遍历到左子树底端
            if(treeNode.rightChild == null || treeNode.rightChild == lastVisit){
                System.out.println(treeNode.data);
                lastVisit = treeNode;
            }else {
                //左子树刚被访问过，则需进入右子树(根节点需再次入栈)
                stack.push(treeNode);
                treeNode = treeNode.rightChild;
                while (treeNode!=null){
                    stack.push(treeNode);
                    treeNode = treeNode.leftChild;
                }
            }
        }
    }
    public static void main(String[] args) {
        LinkedList<Integer> inputList = new LinkedList<Integer>(Arrays.asList(
                new Integer[]{
                        3,2,9,null,null,10,null,null,8,null,4
                }
        ));
        TreeNode treeNode = createBinaryTree(inputList);
        System.out.println("前序");
        preOrderTraveral(treeNode);
        System.out.println("中序");
        inOrderTraveral(treeNode);
        System.out.println("后序");
        postOrderTraveral(treeNode);
    }
}
```

![二叉树](imgs/binarytree.png)

##### 2.**广度优先遍历**

层序遍历

```java
//层序遍历
public static void levelOrderTraversal(TreeNode root){
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()){
        TreeNode node = queue.poll();
        System.out.println(node.data);
        if(node.leftChild!=null){
            queue.offer(node.leftChild);
        }
        if(node.rightChild!=null){
            queue.offer(node.rightChild);
        }
    }
}
```

## 七、二叉堆

+ 最大堆

  任何一个父节点的值，都大于或等于它左右孩子节点的值

+ 最小堆

  任何一个父节点的值，都小于或等于它左右孩子节点的值

+ 堆顶

  二叉堆的根节点

+ **二叉堆的自我调整**

  + 插入节点 O(logn)

    插入位置是完全二叉树的最后一个位置，如果新节点比父节点的值小（对于最小堆来说）则让新节点‘上浮’，和父节点交换位置。

  + 删除节点 O(logn)

    删除位置为堆顶，把最后一个节点临时补到原本堆顶的位置，当其比左右孩子节点中最小的一个还要大时（对于最小堆来说），则让其‘下沉’，和最小的节点交换位置。

  + 构建二叉堆 O(n)

    把无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次’下沉‘。

```java
public class MyHeap {
    //二叉堆虽然是一个完全二叉树，但其使用顺序存储，均存储在数组中
    //‘上浮’调整
    public static void upAdjust(int[] array){
        int childIndex = array.length-1;
        int parentIndex = (childIndex-1)/2;
        //temp保存插入的叶子节点值，用于最后的赋值
        int temp = array[childIndex];
        while (childIndex>0 && temp<array[parentIndex]){
            //无须真正交换，单向赋值即可
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (childIndex-1)/2;
        }
        array[childIndex]=temp;
    }
    //‘下沉’调整
    public static void downAdjust(int []array,int parentIndex,int length){
        //temp保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2*parentIndex+1;
        while (childIndex<length){
            //如果有右孩子，且右孩子的小于左孩子的值，则定位到右孩子
            if(childIndex+1<length && array[childIndex+1]<array[childIndex]){
                childIndex++;
            }
            //如果父节点小于任何一个孩子的值，则直接跳出
            if(temp<=array[childIndex])
                break;
            //无须真正交换，单向赋值即可
            array[parentIndex]=array[childIndex];
            parentIndex = childIndex;
            childIndex = 2*childIndex+1;
        }
        array[parentIndex]=temp;
    }
    //构建堆
    public static void buildHeap(int []array){
        for(int i = (array.length-2)/2;i>=0;i--){
            downAdjust(array,i,array.length);
        }
    }

    public static void main(String[] args) {
        int[]array = new int[]{
                1,3,2,6,5,7,8,9,10,0
        };
        upAdjust(array);
        System.out.println(Arrays.toString(array));
        array = new int[]{
                7,1,3,10,5,2,8,9,6
        };
        buildHeap(array);
        System.out.println(Arrays.toString(array));
    }
}
```

## 八、优先队列

+ 最大优先队列

  无论入队顺序如何，都是当前最大的元素优先出队

+ 最小优先队列

  无论入队顺序如何，都是当前最小的元素优先出队

+ 实现

  使用最大堆来实现最大优先队列，那么，每一次入队就是堆的插入操作，每一次出队，就是堆的删除堆顶操作。

```java
public class PriorityQueue {
    private int[] array;
    private int size;
    public PriorityQueue(){
        array = new int[32];
    }
    //入队
    public void enQueue(int key){
        //队列长度超出范围，扩容
        if(size>=array.length){
            resize();
        }
        array[size++]=key;
        upAdjust();
    }
    //出队
    public int deQueue()throws Exception{
        if(size<=0){
            throw new Exception("the queue is empty");
        }
        //获取堆顶元素
        int head = array[0];
        //让最后一个元素移动到堆顶
        array[0]=array[--size];
        downAdjust();
        return head;
    }
    //上浮调整
    private void upAdjust(){
        int childIndex = size-1;
        int parentIndex = (childIndex-1)/2;
        //temp 保存插入的叶子节点值，用于最后的赋值
        int  temp = array[childIndex];
        while (childIndex>0 && temp>array[parentIndex]){
            //无须真正交换，单向赋值即可
            array[childIndex]=array[parentIndex];
            childIndex=parentIndex;
            parentIndex=parentIndex/2;
        }
        array[childIndex]=temp;
    }
    //下沉调整
    private void downAdjust(){
        //temp 保存父节点的值，用于最后的赋值
        int parentIndex = 0;
        int temp = array[parentIndex];
        int childIndex = 1;
        while (childIndex<size){
            //如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子
            if(childIndex+1<size && array[childIndex+1]>array[childIndex]){
                childIndex++;
            }
            //如果父节点大于任何一个孩子的值，直接跳出
            if(temp>=array[childIndex]){
                break;
            }
            //无须真正交换，单向赋值即可
            array[parentIndex]=array[childIndex];
            parentIndex = childIndex;
            childIndex = 2* childIndex +1;
        }
        array[parentIndex]=temp;
    }
    //队列扩容
    private void resize(){
        int newSize = this.size*2;
        this.array = Arrays.copyOf(this.array,newSize);
    }

    public static void main(String[] args) throws Exception {
        PriorityQueue priorityQueue = new PriorityQueue();
        priorityQueue.enQueue(3);
        priorityQueue.enQueue(5);
        priorityQueue.enQueue(10);
        priorityQueue.enQueue(2);
        priorityQueue.enQueue(7);
        System.out.println("出队元素："+priorityQueue.deQueue());
        System.out.println("出队元素："+priorityQueue.deQueue());
    }
}
```

# (二)、排序算法


# 面经
[toc]
# 1000W高考成绩，0-750，数据爬取，要求输出升序，CPU内存不限，时间复杂度要求O(n)，给出解决方案和展示所用数据结构
用桶排序，开0-750个桶，然后1000w可以分批放入桶中，好处是如果限制条件内存不够可以把上次的结果存成文件，分批计算在汇总。最后按照桶中的计数大小进行排序。
每个桶的数据结构为链表
或者开750/2个桶，每个桶放两个分数，分数高的从链表尾部插入，分数低的从链表头插入。
# 基数排序、桶排序和计数排序的区别
[三个排序](https://blog.csdn.net/qq_19446965/article/details/81517552)
[2.0](https://blog.csdn.net/qq_25026989/article/details/89367954)
![](_v_images/20210122142928348_28013.png)
其中, d 表示位数， k 在基数排序中表示 k 进制，在桶排序中表示桶的个数， maxV 和 minV 表示元
素最大值和最小值。

- 首先，基数排序和计数排序都可以看作是桶排序。
- 计数排序本质上是一种特殊的桶排序，当桶的个数取最大( maxV-minV+1 )的时候，就变成了计数排序。
- 基数排序也是一种桶排序。桶排序是按值区间划分桶，基数排序是按数位来划分；基数排序可以看做是多轮桶排序，每个数位上都进行一轮桶排序。
- 当用最大值作为基数时，基数排序就退化成了计数排序。 当使用2进制时， k=2 最小，位数 d 最大，时间复杂度 O(nd)会变大，空间复杂度 O(n+k) 会变小。
- 当用最大值作为基数时， k=maxV 最大， d=1 最小，此时时间复杂度 O(nd) 变小，但是空间复杂度 O(n+k)会急剧增大，此时基数排序退化成了计数排序。

# 32、64位系统有什么区别
32位和64位操作系统是指，CPU一次处理数据的能力是32位还是64位，这里涉及到的是处理器运算位数。简单的说32位系统的地址总线是32位的，而64位系统的地址总线是64位的。
（1）设计初衷不同。64位操作系统的设计初衷是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域中需要大量内存和浮点性能的客户需求。换句简明的话说就是：它们是高科技人员使用本行业特殊软件的运行平台。而32位操作系统是为普通用户设计的。

（2）要求配置不同。64位操作系统只能安装在64位电脑上(CPU必须是64位的)。同时需要安装64位常用软件以发挥64位（x64）的最佳性能。32位操作系统则可以安装在32位(32位CPU)或64位(64位CPU)电脑上。当然，32位操作系统安装在64位电脑上，其硬件恰似“大马拉小车”：64位效能就会大打折扣。

（3）运算速度不同。64位CPU GPRs(General-Purpose Registers，通用寄存器)的数据宽度为64位，64位指令集可以运行64位数据指令，也就是说处理器一次可提取64位数据(只要两个指令，一次提取8个字节的数据)，比32位(需要四个指令,一次提取4个字节的数据)提高了一倍，理论上性能会相应提升1倍。

（4）寻址能力不同。64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，因此一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。比如，Windows Vista x64 Edition支持多达**128 GB的内存和多达16 TB**的虚拟内存，而**32位CPU和操作系统最大只可支持4G内存**。

（5）软件普及不同。目前，64位常用软件比32位常用软件，要少得多的多。道理很简单：使用64位操作系统的用户相对较少。因此，软件开发商必须考虑“投入产出比”，将有限资金投入到更多使用群体的软件之中。这也是为什么64位软件价格相对昂贵的重要原因。

对于目前来讲32位依然是主流，并且目前的64位系统其实只是当前32位系统的简单改进版本，依然保持着兼容32位系统，但依然我们会发现与部分软件存在不兼容。64位系统的发展依然有很长的路要走。

# HTTP1.0和HTTP1.1的一些区别
HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

+ **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

+ **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

+ **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

+ **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

+ **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
# kill -9 和 kill -15
+ **kill -15 pid（默认）**: 一般不加参数kill是使用-15，执行完该指令后，操作系统会发送一个 SIGTERM 信号给对应的程序。当程序接收到该信号后，可能会发生以下几种情况的一种：
1. 当前程序立刻停止；
2. 程序释放相应资源，然后再停止；
3. 程序可能仍然继续运行。
大部分程序会先释放自己的资源，然后再停止。但是也有程序可以在接受到信号量后，继续做其他一些事情，并且这些事情是可以配置的。如果程序正在等待IO，可能就不会立马做出响应。也就是说，-15 SIGTERM 是可能被阻塞、被忽略的。
+ **kill -9 pid**：表示强制杀死该进程，系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。


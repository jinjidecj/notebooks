# 操作系统
[toc]
# 1. 进程和线程
## 1.1 进程
进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。
一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。
进程具有的特征：
动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
并发性：任何进程都可以同其他进行一起并发执行；
独立性：进程是系统进行资源分配和调度的一个独立单位；
结构性：进程由程序，数据和进程控制块三部分组成
## 1.2 线程
线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**（JDK1.8之后的元空间）资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
**总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**
## 1.3 线程进程的区别
+ 因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，**系统开销比较大**，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，**比进程更节俭，开销比较小，切换速度也比进程快，效率高**，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，**而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉**。
+ 体现在通信机制上面，正因为进程之间互不干扰，相互独立，**进程的通信机制相对很复杂**，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而**线程由于共享数据段所以通信机制很方便**
+ 属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同的进程相互独立。
+ 线程又称为轻量级进程，进程有进程控制块，线程有线程控制块。
> 线程控制块（Thread Control Block，TCB）是与进程的控制块（PCB）相似的子控制块，只是TCB中所保存的线程状态比PCB中保存少而已。
> 进程控制块（Processing Control Block），是操作系统核心中一种数据结构，主要表示进程状态。其作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。 PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。
+ 线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程。
## 1.4 什么时候用进程？什么时候用线程？
+ 1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。
+ 2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
+ 3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；
+ 4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；
+ 5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。

## 1.5 线程共享的资源具体有哪些
a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）

b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的

c. 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的

d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。
## 1.6 线程独享的资源
程序计数器，本地方法栈，虚拟机栈

## 1.7 守护进程，守护线程，用户线程
+ **守护进程**：是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。是一类在后台运行的特殊进程，用于执行特定的系统任务。另一些只在需要的时候才启动，完成任务后就自动结束。
+ **用户线程**：我们平常创建的普通线程。
+ **守护线程：**是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默完成一些系统性的服务，比如垃圾回收线程，JIT线程就可以理解为守护线程。**如果用户线程全部结束**，则意味着这个程序无事可做。守护线程要守护的对象已经不存在了，那么整个应用程序就应该结束。因此，当一个Java应用内只有守护线程时，Java虚拟机自然退出。
```java
public class DaemonDemo {
    public static void main(String[] args) {
        Thread daemonThread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        System.out.println("i am alive");
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        System.out.println("finally block");
                    }
                }
            }
        });
        daemonThread.setDaemon(true);
        daemonThread.start();
        //确保main线程结束前能给daemonThread能够分到时间片
        try {
            Thread.sleep(800);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
daemonThread.setDaemon(true)设置daemonThread为守护线程。
注意：
+ 1. 守护线程必须在start之前设置，否则会报错。
+ 2.在Daemon线程中产生的新线程也是Daemon的。
+ 3.守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。
+ 4.Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。
**守护线程的意义及应用场景**
当主线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。如：Java垃圾回收线程就是一个典型的守护线程；内存资源或者线程的管理，但是非守护线程也可以。

## 1.8 并行和并发
**并发**
    在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。
    并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。
**并行**
    当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。
    其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。

## 1.9 协程
协程是比线程更小的一种执行单元，你可以认为是轻量级的线程，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。
协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。
**协程的优势**
+ 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；
+ 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

## 1.10 进程之进程间的通信方式
### 管道( pipe )
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
### 有名管道 (named pipe) 
有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
### 信号量( semophore )
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
### 消息队列( message queue ) 
消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
### 信号 ( sinal ) 
信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
### 共享内存( shared memory )
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
### 套接字( socket ) 
套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

# 2. 操作系统中段页式系统访存次数
三次访问内存。
第一次访问是访问内存中的段表，从中取得页表始址；
第二次是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；
第三次访问从第二次访问所得的地址中，取出指令或数据。
**如何减少访存次数**
为了访存的次数不这么多，在地址变换机构中增设一个高速缓冲寄存器，从中得到相应页的物理块号。
**页式为2、段式为2、段页式为3次**
